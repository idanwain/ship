/**
 * This module is includes the main function which simulates the cartesian loop such that for every travel folder
 * and every algorithm in runs the simulation. given a list of {Alg1,Alg2,Alg3...} and a list of {Travel1,Travel2..}
 * for every i,and j the simulator runs Algi over Travelj, every iteration over Travelj the algorithm gets from the
 * simulator the next port cargo file, which includes containers awaiting at this port then :
 * 1. the algorithm generates crane instructions file including Load/Unload/Move/Reject operations
 * 2. the simulator validates the crane instructions file generated by the algorithm, and gather erroneous operations
 * after finishing Travelj and prior to run Travelx the simulator saves the information it gathered in a data structure.
 * at the end while every Algi iterated over every Travelj the simulator creates 2 output files :
 * 1. Simulation.errors  - including the general errors the simulator found, so the errors it found validating the algs.
 * 2. Simulation.results - representing the total number of L/R/M instructions of every algorithm on every Travel, also
 * the total number of errors a given algorithm made over all the travel folders, sorted by following criteria :
 * 1. first will be shown the algorithm with the lowest errors occurred(generated by the simulator).
 * 2. second will be compared only iff 2 algorithms errors count is same the it will be sorted by number of instructions.
  Note - if no output path given -> output files will be at the directory the main program runs from.
 */
#include <string>
#include "../common/Ship.h"
#include "../common/Parser.h"
#include "AlgorithmFactoryRegistrar.h"
#include "ThreadPoolExecuter.h"
#include "TaskProducer.h"
#include <dlfcn.h>
#include <memory>
#include "Util.h"

string mainTravelPath;
string mainAlgorithmsPath;
string mainOutputPath;
int threadNum;

int main(int argc, char** argv) {
    map<string ,std::function<std::unique_ptr<AbstractAlgorithm>()>> map;
    vector<std::shared_ptr<Travel>> TravelsVec;
    vector<fs::path> algPaths;
    tasksContainer tasks;
    list<string> generalErrors;

    handleFlags(argc,argv);
    initListOfTravels(mainTravelPath,generalErrors,TravelsVec,mainOutputPath);
    getAlgSoFiles(algPaths);

    auto& registrar = AlgorithmFactoryRegistrar::getRegistrar();
    registrar.dynamicLoadSoFiles(algPaths, map,generalErrors);
    initTasksContainer(tasks,map,TravelsVec);

    /*Case multi threaded*/
    if(threadNum > 1){
        ThreadPoolExecuter executer {TaskProducer(tasks), threadNum};
        executer.start();
        executer.wait_till_finish();
    } else {
        for(auto& travel : TravelsVec){
            SimulatorObj simulator;
            travel->getShip() = extractArgsForShip(travel, simulator);
            vector<pair<string,std::unique_ptr<AbstractAlgorithm>>> algVec = initAlgorithmList(map);
            if(travel->getShip() != nullptr){
                for (auto &alg : algVec) {
                    int errCode1 = 0, errCode2 = 0;
                    WeightBalanceCalculator algCalc;
                    try {
                        errCode1 = alg.second->readShipPlan(travel->getPlanPath().string());
                        errCode2 = alg.second->readShipRoute(travel->getRoutePath().string());
                        errCode1 |= algCalc.readShipPlan(travel->getPlanPath().string());
                    }
                    catch(...) {
                        travel->setAlgCrashError(alg.first);
                        continue;
                    }
                    alg.second->setWeightBalanceCalculator(algCalc);
                    simulator.updateErrorCodes(errCode1 + errCode2, "alg");
                    simulator.setShipAndCalculator(travel->getShip(), travel->getPlanPath().string());
                    simulator.runAlgorithm(alg, travel);
                }
            }
            else
                travel->setErroneousTravel();
            simulator.prepareNextIteration();
        }
    }

    createResultsFile(mainOutputPath, TravelsVec,map);
    createErrorsFile(mainOutputPath,TravelsVec,generalErrors);
    return (EXIT_SUCCESS);
}